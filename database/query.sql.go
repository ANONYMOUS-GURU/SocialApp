// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package database

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const activeSocialRequestExists = `-- name: activeSocialRequestExists :one
SELECT EXISTS(
  SELECT 1
  FROM SocialRequests sr
  WHERE sr.user_id = $1
    AND sr.target_user_id = $2
    AND sr.request_type = $3
    AND sr.request_status == 'ACTIVE'
)
`

type activeSocialRequestExistsParams struct {
	UserID       string
	TargetUserID string
	RequestType  string
}

func (q *Queries) activeSocialRequestExists(ctx context.Context, arg activeSocialRequestExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, activeSocialRequestExists, arg.UserID, arg.TargetUserID, arg.RequestType)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createConversation = `-- name: createConversation :one
INSERT INTO Conversations (id, is_group, owner_id, name, description, image_url, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, is_group, owner_id, name, description, image_url, created_at, updated_at, deleted_at, last_message_at
`

type createConversationParams struct {
	ID          string
	IsGroup     bool
	OwnerID     sql.NullString
	Name        sql.NullString
	Description sql.NullString
	ImageUrl    sql.NullString
	CreatedAt   int64
}

func (q *Queries) createConversation(ctx context.Context, arg createConversationParams) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, createConversation,
		arg.ID,
		arg.IsGroup,
		arg.OwnerID,
		arg.Name,
		arg.Description,
		arg.ImageUrl,
		arg.CreatedAt,
	)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.IsGroup,
		&i.OwnerID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.LastMessageAt,
	)
	return i, err
}

const createConversationParticipant = `-- name: createConversationParticipant :exec
INSERT INTO ConversationParticipants (conversation_id, user_id, is_owner, joined_at, last_message_seen_at)
VALUES ($1, $2, $3, $4, $5)
`

type createConversationParticipantParams struct {
	ConversationID    string
	UserID            string
	IsOwner           bool
	JoinedAt          int64
	LastMessageSeenAt int64
}

func (q *Queries) createConversationParticipant(ctx context.Context, arg createConversationParticipantParams) error {
	_, err := q.db.ExecContext(ctx, createConversationParticipant,
		arg.ConversationID,
		arg.UserID,
		arg.IsOwner,
		arg.JoinedAt,
		arg.LastMessageSeenAt,
	)
	return err
}

const createMessage = `-- name: createMessage :one
INSERT INTO Messages (id, body, conversation_id, sender_id, delivered_count, seen_count, sent_to_count, sent_at, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING id, body, conversation_id, sender_id, delivered_count, seen_count, sent_to_count, sent_at, created_at
`

type createMessageParams struct {
	ID             string
	Body           string
	ConversationID string
	SenderID       string
	DeliveredCount int32
	SeenCount      int32
	SentToCount    int32
	SentAt         int64
	CreatedAt      int64
}

func (q *Queries) createMessage(ctx context.Context, arg createMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, createMessage,
		arg.ID,
		arg.Body,
		arg.ConversationID,
		arg.SenderID,
		arg.DeliveredCount,
		arg.SeenCount,
		arg.SentToCount,
		arg.SentAt,
		arg.CreatedAt,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.Body,
		&i.ConversationID,
		&i.SenderID,
		&i.DeliveredCount,
		&i.SeenCount,
		&i.SentToCount,
		&i.SentAt,
		&i.CreatedAt,
	)
	return i, err
}

const createMessageUserMap = `-- name: createMessageUserMap :exec
INSERT INTO MessageUserMap (message_id, receiver_id)
VALUES ($1, $2)
`

type createMessageUserMapParams struct {
	MessageID  string
	ReceiverID string
}

func (q *Queries) createMessageUserMap(ctx context.Context, arg createMessageUserMapParams) error {
	_, err := q.db.ExecContext(ctx, createMessageUserMap, arg.MessageID, arg.ReceiverID)
	return err
}

const createNewCalendarEvent = `-- name: createNewCalendarEvent :one
INSERT INTO CalendarEvents (id, user_id, event_title, event_description, from_time, to_time, is_recurring, game_id, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, user_id, event_title, event_description, from_time, to_time, is_recurring, game_id, created_at, updated_at, deleted_at
`

type createNewCalendarEventParams struct {
	ID               string
	UserID           string
	EventTitle       string
	EventDescription string
	FromTime         int64
	ToTime           int64
	IsRecurring      bool
	GameID           string
	CreatedAt        int64
}

func (q *Queries) createNewCalendarEvent(ctx context.Context, arg createNewCalendarEventParams) (Calendarevent, error) {
	row := q.db.QueryRowContext(ctx, createNewCalendarEvent,
		arg.ID,
		arg.UserID,
		arg.EventTitle,
		arg.EventDescription,
		arg.FromTime,
		arg.ToTime,
		arg.IsRecurring,
		arg.GameID,
		arg.CreatedAt,
	)
	var i Calendarevent
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EventTitle,
		&i.EventDescription,
		&i.FromTime,
		&i.ToTime,
		&i.IsRecurring,
		&i.GameID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createNewCalendarEventRequest = `-- name: createNewCalendarEventRequest :one
INSERT INTO CalendarEventRequests (
  id,
  event_id,
  requesting_user_id,
  request_message,
  request_status,
  created_at
)
VALUES (
  $1, $2, $3, $4, "ACTIVE", $5
) RETURNING id, event_id, requesting_user_id, request_message, request_status, created_at, updated_at
`

type createNewCalendarEventRequestParams struct {
	ID               string
	EventID          string
	RequestingUserID string
	RequestMessage   string
	CreatedAt        int64
}

func (q *Queries) createNewCalendarEventRequest(ctx context.Context, arg createNewCalendarEventRequestParams) (Calendareventrequest, error) {
	row := q.db.QueryRowContext(ctx, createNewCalendarEventRequest,
		arg.ID,
		arg.EventID,
		arg.RequestingUserID,
		arg.RequestMessage,
		arg.CreatedAt,
	)
	var i Calendareventrequest
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.RequestingUserID,
		&i.RequestMessage,
		&i.RequestStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createNewCalendarInvite = `-- name: createNewCalendarInvite :one
INSERT INTO CalendarEventInvites (
  id,
  event_id,
  invited_user_id,
  invite_message,
  invite_status,
  created_at
)
VALUES (
  $1, -- invite ID (string)
  $2, -- event ID (string)
  $3, -- invited user ID (string)
  $4, -- invite message (text)
  $5,
  $6 -- timestamp of creation
) RETURNING id, event_id, invited_user_id, invite_message, invite_status, created_at, updated_at
`

type createNewCalendarInviteParams struct {
	ID            string
	EventID       string
	InvitedUserID string
	InviteMessage string
	InviteStatus  string
	CreatedAt     int64
}

func (q *Queries) createNewCalendarInvite(ctx context.Context, arg createNewCalendarInviteParams) (Calendareventinvite, error) {
	row := q.db.QueryRowContext(ctx, createNewCalendarInvite,
		arg.ID,
		arg.EventID,
		arg.InvitedUserID,
		arg.InviteMessage,
		arg.InviteStatus,
		arg.CreatedAt,
	)
	var i Calendareventinvite
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.InvitedUserID,
		&i.InviteMessage,
		&i.InviteStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createNewSocialRequest = `-- name: createNewSocialRequest :one
INSERT INTO SocialRequests (id, user_id, target_user_id, request_type, request_message, created_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, target_user_id, request_type, request_message, request_status, created_at, updated_at
`

type createNewSocialRequestParams struct {
	ID             string
	UserID         string
	TargetUserID   string
	RequestType    string
	RequestMessage string
	CreatedAt      int64
}

func (q *Queries) createNewSocialRequest(ctx context.Context, arg createNewSocialRequestParams) (Socialrequest, error) {
	row := q.db.QueryRowContext(ctx, createNewSocialRequest,
		arg.ID,
		arg.UserID,
		arg.TargetUserID,
		arg.RequestType,
		arg.RequestMessage,
		arg.CreatedAt,
	)
	var i Socialrequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TargetUserID,
		&i.RequestType,
		&i.RequestMessage,
		&i.RequestStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: createUser :exec
INSERT INTO Users (id, name, username, email, description, image_url, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type createUserParams struct {
	ID          string
	Name        string
	Username    string
	Email       string
	Description string
	ImageUrl    string
	CreatedAt   int64
}

func (q *Queries) createUser(ctx context.Context, arg createUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser,
		arg.ID,
		arg.Name,
		arg.Username,
		arg.Email,
		arg.Description,
		arg.ImageUrl,
		arg.CreatedAt,
	)
	return err
}

const deleteCalendarInvite = `-- name: deleteCalendarInvite :exec
DELETE FROM CalendarEventInvites
WHERE id = $1
`

func (q *Queries) deleteCalendarInvite(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteCalendarInvite, id)
	return err
}

const fAreUsersFriends = `-- name: fAreUsersFriends :one
SELECT EXISTS(
  SELECT 1
  FROM Friends
  WHERE (user1_id = $1 AND user2_id = $2) OR (user1_id = $2 AND user2_id = $1)
)
`

type fAreUsersFriendsParams struct {
	User1ID string
	User2ID string
}

func (q *Queries) fAreUsersFriends(ctx context.Context, arg fAreUsersFriendsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, fAreUsersFriends, arg.User1ID, arg.User2ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const fIsSocialRequestActive = `-- name: fIsSocialRequestActive :one
SELECT EXISTS(
  SELECT 1
  FROM SocialRequests sr
  WHERE sr.user_id = $1
    AND sr.request_status = 'ACTIVE'
    AND sr.target_user_id = $2
    AND sr.request_type = $3
)
`

type fIsSocialRequestActiveParams struct {
	UserID       string
	TargetUserID string
	RequestType  string
}

func (q *Queries) fIsSocialRequestActive(ctx context.Context, arg fIsSocialRequestActiveParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, fIsSocialRequestActive, arg.UserID, arg.TargetUserID, arg.RequestType)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const fIsUserAlreadyAParticipantOfCalendarEvent = `-- name: fIsUserAlreadyAParticipantOfCalendarEvent :one
SELECT EXISTS (
  SELECT 1
  FROM CalendarEventParticipants
  WHERE user_id = $1
  AND event_id = $2
)
`

type fIsUserAlreadyAParticipantOfCalendarEventParams struct {
	UserID  string
	EventID string
}

func (q *Queries) fIsUserAlreadyAParticipantOfCalendarEvent(ctx context.Context, arg fIsUserAlreadyAParticipantOfCalendarEventParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, fIsUserAlreadyAParticipantOfCalendarEvent, arg.UserID, arg.EventID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const fIsUserOrganizerOfEvent = `-- name: fIsUserOrganizerOfEvent :one
SELECT EXISTS (
  SELECT 1
  FROM CalendarEvents
  WHERE id = $1 AND user_id = $2
)
`

type fIsUserOrganizerOfEventParams struct {
	ID     string
	UserID string
}

func (q *Queries) fIsUserOrganizerOfEvent(ctx context.Context, arg fIsUserOrganizerOfEventParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, fIsUserOrganizerOfEvent, arg.ID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const fMessageIsInUsersConversation = `-- name: fMessageIsInUsersConversation :one
SELECT EXISTS (
  SELECT 1
  FROM Conversations c
  INNER JOIN Messages m ON c.id = m.conversation_id
  INNER JOIN ConversationParticipants cp ON c.id = cp.conversation_id
  WHERE m.id = $1 AND cp.user_id = $2
)
`

type fMessageIsInUsersConversationParams struct {
	ID     string
	UserID string
}

func (q *Queries) fMessageIsInUsersConversation(ctx context.Context, arg fMessageIsInUsersConversationParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, fMessageIsInUsersConversation, arg.ID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const fUserFollowsAnotherUser = `-- name: fUserFollowsAnotherUser :one
SELECT EXISTS(
  SELECT 1
  FROM Follows
  WHERE follower_id = $1 AND followed_id = $2
)
`

type fUserFollowsAnotherUserParams struct {
	FollowerID string
	FollowedID string
}

func (q *Queries) fUserFollowsAnotherUser(ctx context.Context, arg fUserFollowsAnotherUserParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, fUserFollowsAnotherUser, arg.FollowerID, arg.FollowedID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getAllCalendarEventParticipants = `-- name: getAllCalendarEventParticipants :many
SELECT cep.event_id, cep.user_id, cep.joined_at, cep.is_organizer, u.name, u.image_url
FROM CalendarEventParticipants cep
INNER JOIN Users u ON cep.user_id = u.id
WHERE cep.event_id = $1
  AND cep.joined_at > $2
ORDER BY cep.joined_at ASC
LIMIT $3
`

type getAllCalendarEventParticipantsParams struct {
	EventID  string
	JoinedAt int64
	Limit    int32
}

type getAllCalendarEventParticipantsRow struct {
	EventID     string
	UserID      string
	JoinedAt    int64
	IsOrganizer bool
	Name        string
	ImageUrl    string
}

func (q *Queries) getAllCalendarEventParticipants(ctx context.Context, arg getAllCalendarEventParticipantsParams) ([]getAllCalendarEventParticipantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCalendarEventParticipants, arg.EventID, arg.JoinedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getAllCalendarEventParticipantsRow
	for rows.Next() {
		var i getAllCalendarEventParticipantsRow
		if err := rows.Scan(
			&i.EventID,
			&i.UserID,
			&i.JoinedAt,
			&i.IsOrganizer,
			&i.Name,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCalendarInvitesForEvent = `-- name: getAllCalendarInvitesForEvent :many
SELECT id, event_id, invited_user_id, invite_message, invite_status, created_at, updated_at
FROM CalendarEventInvites
WHERE event_id = $1
  AND created_at < $2
  AND invite_status = $4
LIMIT $3
`

type getAllCalendarInvitesForEventParams struct {
	EventID      string
	CreatedAt    int64
	Limit        int32
	InviteStatus string
}

func (q *Queries) getAllCalendarInvitesForEvent(ctx context.Context, arg getAllCalendarInvitesForEventParams) ([]Calendareventinvite, error) {
	rows, err := q.db.QueryContext(ctx, getAllCalendarInvitesForEvent,
		arg.EventID,
		arg.CreatedAt,
		arg.Limit,
		arg.InviteStatus,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Calendareventinvite
	for rows.Next() {
		var i Calendareventinvite
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.InvitedUserID,
			&i.InviteMessage,
			&i.InviteStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCalendarInvitesForUser = `-- name: getAllCalendarInvitesForUser :many
SELECT id, event_id, invited_user_id, invite_message, invite_status, created_at, updated_at
FROM CalendarEventInvites
WHERE invited_user_id = $1
  AND created_at < $2
  AND invite_status = $4
ORDER BY created_at DESC
LIMIT $3
`

type getAllCalendarInvitesForUserParams struct {
	InvitedUserID string
	CreatedAt     int64
	Limit         int32
	InviteStatus  string
}

func (q *Queries) getAllCalendarInvitesForUser(ctx context.Context, arg getAllCalendarInvitesForUserParams) ([]Calendareventinvite, error) {
	rows, err := q.db.QueryContext(ctx, getAllCalendarInvitesForUser,
		arg.InvitedUserID,
		arg.CreatedAt,
		arg.Limit,
		arg.InviteStatus,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Calendareventinvite
	for rows.Next() {
		var i Calendareventinvite
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.InvitedUserID,
			&i.InviteMessage,
			&i.InviteStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCalendarRequestForEvent = `-- name: getAllCalendarRequestForEvent :many
SELECT cer.id, cer.event_id, cer.requesting_user_id, cer.request_message, cer.request_status, cer.created_at, cer.updated_at
FROM CalendarEventRequests cer
WHERE cer.event_id = $1
  AND cer.request_status = $2
  AND cer.created_at > $3
ORDER BY cer.created_at ASC
LIMIT $4
`

type getAllCalendarRequestForEventParams struct {
	EventID       string
	RequestStatus string
	CreatedAt     int64
	Limit         int32
}

func (q *Queries) getAllCalendarRequestForEvent(ctx context.Context, arg getAllCalendarRequestForEventParams) ([]Calendareventrequest, error) {
	rows, err := q.db.QueryContext(ctx, getAllCalendarRequestForEvent,
		arg.EventID,
		arg.RequestStatus,
		arg.CreatedAt,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Calendareventrequest
	for rows.Next() {
		var i Calendareventrequest
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.RequestingUserID,
			&i.RequestMessage,
			&i.RequestStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMessagesAfterGivenTime = `-- name: getAllMessagesAfterGivenTime :many
WITH ranked_messages AS (
  SELECT m.id, m.body, m.conversation_id, m.sender_id, m.delivered_count, m.seen_count, m.sent_to_count, m.sent_at, m.created_at
  FROM Messages m
  INNER JOIN ConversationParticipants cp ON m.conversation_id = cp.conversation_id
  WHERE cp.user_id = $1 AND m.created_at > $2
  ORDER BY m.created_at ASC
)
SELECT id, body, conversation_id, sender_id, delivered_count, seen_count, sent_to_count, sent_at, created_at
FROM ranked_messages
LIMIT $3
`

type getAllMessagesAfterGivenTimeParams struct {
	UserID    string
	CreatedAt int64
	Limit     int32
}

type getAllMessagesAfterGivenTimeRow struct {
	ID             string
	Body           string
	ConversationID string
	SenderID       string
	DeliveredCount int32
	SeenCount      int32
	SentToCount    int32
	SentAt         int64
	CreatedAt      int64
}

func (q *Queries) getAllMessagesAfterGivenTime(ctx context.Context, arg getAllMessagesAfterGivenTimeParams) ([]getAllMessagesAfterGivenTimeRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllMessagesAfterGivenTime, arg.UserID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getAllMessagesAfterGivenTimeRow
	for rows.Next() {
		var i getAllMessagesAfterGivenTimeRow
		if err := rows.Scan(
			&i.ID,
			&i.Body,
			&i.ConversationID,
			&i.SenderID,
			&i.DeliveredCount,
			&i.SeenCount,
			&i.SentToCount,
			&i.SentAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMessagesForConversation = `-- name: getAllMessagesForConversation :many
WITH ranked_messages AS (
  SELECT m.id, m.body, m.conversation_id, m.sender_id, m.delivered_count, m.seen_count, m.sent_to_count, m.sent_at, m.created_at
  FROM Messages m
  WHERE m.conversation_id = $1 AND m.created_at > $2
  ORDER BY m.created_at ASC
)
SELECT id, body, conversation_id, sender_id, delivered_count, seen_count, sent_to_count, sent_at, created_at
FROM ranked_messages
LIMIT $3
`

type getAllMessagesForConversationParams struct {
	ConversationID string
	CreatedAt      int64
	Limit          int32
}

type getAllMessagesForConversationRow struct {
	ID             string
	Body           string
	ConversationID string
	SenderID       string
	DeliveredCount int32
	SeenCount      int32
	SentToCount    int32
	SentAt         int64
	CreatedAt      int64
}

func (q *Queries) getAllMessagesForConversation(ctx context.Context, arg getAllMessagesForConversationParams) ([]getAllMessagesForConversationRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllMessagesForConversation, arg.ConversationID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getAllMessagesForConversationRow
	for rows.Next() {
		var i getAllMessagesForConversationRow
		if err := rows.Scan(
			&i.ID,
			&i.Body,
			&i.ConversationID,
			&i.SenderID,
			&i.DeliveredCount,
			&i.SeenCount,
			&i.SentToCount,
			&i.SentAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPendingSocialRequestForUser = `-- name: getAllPendingSocialRequestForUser :many
SELECT id, user_id, target_user_id, request_type, request_message, request_status, created_at, updated_at
FROM SocialRequests sr
WHERE sr.user_id = $1
  AND sr.request_status = 'ACTIVE'
  AND sr.created_at > $2
ORDER BY sr.created_at ASC
LIMIT $3
`

type getAllPendingSocialRequestForUserParams struct {
	UserID    string
	CreatedAt int64
	Limit     int32
}

func (q *Queries) getAllPendingSocialRequestForUser(ctx context.Context, arg getAllPendingSocialRequestForUserParams) ([]Socialrequest, error) {
	rows, err := q.db.QueryContext(ctx, getAllPendingSocialRequestForUser, arg.UserID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Socialrequest
	for rows.Next() {
		var i Socialrequest
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TargetUserID,
			&i.RequestType,
			&i.RequestMessage,
			&i.RequestStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersInConversation = `-- name: getAllUsersInConversation :many
SELECT conversation_id, user_id, is_owner, last_message_seen_at, joined_at, deleted_at FROM ConversationParticipants WHERE conversation_id = $1
`

func (q *Queries) getAllUsersInConversation(ctx context.Context, conversationID string) ([]Conversationparticipant, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsersInConversation, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conversationparticipant
	for rows.Next() {
		var i Conversationparticipant
		if err := rows.Scan(
			&i.ConversationID,
			&i.UserID,
			&i.IsOwner,
			&i.LastMessageSeenAt,
			&i.JoinedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCalendarEventForId = `-- name: getCalendarEventForId :one
SELECT id, user_id, event_title, event_description, from_time, to_time, is_recurring, game_id, created_at, updated_at, deleted_at FROM CalendarEvents
WHERE id = $1
`

func (q *Queries) getCalendarEventForId(ctx context.Context, id string) (Calendarevent, error) {
	row := q.db.QueryRowContext(ctx, getCalendarEventForId, id)
	var i Calendarevent
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EventTitle,
		&i.EventDescription,
		&i.FromTime,
		&i.ToTime,
		&i.IsRecurring,
		&i.GameID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getConversationByID = `-- name: getConversationByID :one
SELECT id, is_group, owner_id, name, description, image_url, created_at, updated_at, deleted_at, last_message_at FROM Conversations WHERE id = $1
`

func (q *Queries) getConversationByID(ctx context.Context, id string) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, getConversationByID, id)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.IsGroup,
		&i.OwnerID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.LastMessageAt,
	)
	return i, err
}

const getFollowersOfUser = `-- name: getFollowersOfUser :many
SELECT u.id, u.name, u.image_url, f.created_at
FROM Follows f
INNER JOIN Users u ON f.follower_id = u.id
WHERE f.followed_id = $1 AND f.created_at > $2
ORDER BY f.created_at ASC
LIMIT $3
`

type getFollowersOfUserParams struct {
	FollowedID string
	CreatedAt  int64
	Limit      int32
}

type getFollowersOfUserRow struct {
	ID        string
	Name      string
	ImageUrl  string
	CreatedAt int64
}

func (q *Queries) getFollowersOfUser(ctx context.Context, arg getFollowersOfUserParams) ([]getFollowersOfUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getFollowersOfUser, arg.FollowedID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getFollowersOfUserRow
	for rows.Next() {
		var i getFollowersOfUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ImageUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendsOfUser = `-- name: getFriendsOfUser :many
SELECT u1.id, u1.name, u1.image_url, f.created_at
FROM Friends f
INNER JOIN Users u1 ON f.user1_id = u1.id
INNER JOIN Users u2 ON f.user2_id = u2.id
WHERE f.user1_id = $1 AND f.created_at > $2
ORDER BY f.created_at ASC
LIMIT $3
`

type getFriendsOfUserParams struct {
	User1ID   string
	CreatedAt int64
	Limit     int32
}

type getFriendsOfUserRow struct {
	ID        string
	Name      string
	ImageUrl  string
	CreatedAt int64
}

func (q *Queries) getFriendsOfUser(ctx context.Context, arg getFriendsOfUserParams) ([]getFriendsOfUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getFriendsOfUser, arg.User1ID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getFriendsOfUserRow
	for rows.Next() {
		var i getFriendsOfUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ImageUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastMessageSeenTimeByUserInConversation = `-- name: getLastMessageSeenTimeByUserInConversation :one
SELECT last_message_seen_at FROM ConversationParticipants
WHERE user_id = $1 AND conversation_id = $2
`

type getLastMessageSeenTimeByUserInConversationParams struct {
	UserID         string
	ConversationID string
}

func (q *Queries) getLastMessageSeenTimeByUserInConversation(ctx context.Context, arg getLastMessageSeenTimeByUserInConversationParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getLastMessageSeenTimeByUserInConversation, arg.UserID, arg.ConversationID)
	var last_message_seen_at int64
	err := row.Scan(&last_message_seen_at)
	return last_message_seen_at, err
}

const getMessageByID = `-- name: getMessageByID :one
SELECT id, body, conversation_id, sender_id, delivered_count, seen_count, sent_to_count, sent_at, created_at FROM Messages WHERE id = $1
`

func (q *Queries) getMessageByID(ctx context.Context, id string) (Message, error) {
	row := q.db.QueryRowContext(ctx, getMessageByID, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.Body,
		&i.ConversationID,
		&i.SenderID,
		&i.DeliveredCount,
		&i.SeenCount,
		&i.SentToCount,
		&i.SentAt,
		&i.CreatedAt,
	)
	return i, err
}

const getMostRecentConversationsForUser = `-- name: getMostRecentConversationsForUser :many
SELECT c.id, c.is_group, c.owner_id, c.name, c.description, c.image_url, c.created_at, c.updated_at, c.deleted_at, c.last_message_at
FROM Conversations c
INNER JOIN ConversationParticipants cp ON c.id = cp.conversation_id
WHERE cp.user_id = $1 AND c.last_message_at < $2
ORDER BY c.last_message_at DESC
LIMIT $3
`

type getMostRecentConversationsForUserParams struct {
	UserID        string
	LastMessageAt int64
	Limit         int32
}

func (q *Queries) getMostRecentConversationsForUser(ctx context.Context, arg getMostRecentConversationsForUserParams) ([]Conversation, error) {
	rows, err := q.db.QueryContext(ctx, getMostRecentConversationsForUser, arg.UserID, arg.LastMessageAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conversation
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(
			&i.ID,
			&i.IsGroup,
			&i.OwnerID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.LastMessageAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostRecentMessagesForUser = `-- name: getMostRecentMessagesForUser :many
SELECT id, body, conversation_id, sender_id, delivered_count, seen_count, sent_to_count, sent_at, created_at FROM Messages
WHERE conversation_id IN (
  SELECT conversation_id
  FROM ConversationParticipants
  WHERE user_id = $1
) AND created_at < $2
ORDER BY created_at DESC
LIMIT $3
`

type getMostRecentMessagesForUserParams struct {
	UserID    string
	CreatedAt int64
	Limit     int32
}

func (q *Queries) getMostRecentMessagesForUser(ctx context.Context, arg getMostRecentMessagesForUserParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, getMostRecentMessagesForUser, arg.UserID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.Body,
			&i.ConversationID,
			&i.SenderID,
			&i.DeliveredCount,
			&i.SeenCount,
			&i.SentToCount,
			&i.SentAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostRecentMessagesForUserInConversation = `-- name: getMostRecentMessagesForUserInConversation :many
SELECT id, body, conversation_id, sender_id, delivered_count, seen_count, sent_to_count, sent_at, created_at FROM Messages
WHERE conversation_id = $1 AND created_at < $2
ORDER BY created_at DESC
LIMIT $3
`

type getMostRecentMessagesForUserInConversationParams struct {
	ConversationID string
	CreatedAt      int64
	Limit          int32
}

func (q *Queries) getMostRecentMessagesForUserInConversation(ctx context.Context, arg getMostRecentMessagesForUserInConversationParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, getMostRecentMessagesForUserInConversation, arg.ConversationID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.Body,
			&i.ConversationID,
			&i.SenderID,
			&i.DeliveredCount,
			&i.SeenCount,
			&i.SentToCount,
			&i.SentAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMutualFriendsOfUser = `-- name: getMutualFriendsOfUser :many
WITH mutual_friends AS (
  SELECT f1.user2_id AS friend_id
  FROM Friends f1
  INNER JOIN Friends f2 ON f1.user1_id = f2.user2_id
  WHERE f1.user1_id = $1
  AND f2.user1_id = $2
  UNION ALL
  SELECT f1.user1_id AS friend_id
  FROM Friends f1
  INNER JOIN Friends f2 ON f1.user2_id = f2.user1_id
  WHERE f1.user1_id = $1
  AND f2.user1_id = $2
)
SELECT u.id, u.name
FROM mutual_friends mf
INNER JOIN Users u ON mf.friend_id = u.id
ORDER BY u.name ASC
LIMIT $3 OFFSET $4
`

type getMutualFriendsOfUserParams struct {
	User1ID   string
	User1ID_2 string
	Limit     int32
	Offset    int32
}

type getMutualFriendsOfUserRow struct {
	ID   string
	Name string
}

func (q *Queries) getMutualFriendsOfUser(ctx context.Context, arg getMutualFriendsOfUserParams) ([]getMutualFriendsOfUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getMutualFriendsOfUser,
		arg.User1ID,
		arg.User1ID_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getMutualFriendsOfUserRow
	for rows.Next() {
		var i getMutualFriendsOfUserRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNumberOfFollowersOfUser = `-- name: getNumberOfFollowersOfUser :one
SELECT COUNT(*)
FROM Follows
WHERE followed_id = $1
`

func (q *Queries) getNumberOfFollowersOfUser(ctx context.Context, followedID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNumberOfFollowersOfUser, followedID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNumberOfUserFriends = `-- name: getNumberOfUserFriends :one
SELECT COUNT(*)
FROM Friends
WHERE user1_id = $1 OR user2_id = $1
`

func (q *Queries) getNumberOfUserFriends(ctx context.Context, user1ID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNumberOfUserFriends, user1ID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNumberOfUsersFollowedByUser = `-- name: getNumberOfUsersFollowedByUser :one
SELECT COUNT(*)
FROM Follows
WHERE follower_id = $1
`

func (q *Queries) getNumberOfUsersFollowedByUser(ctx context.Context, followerID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNumberOfUsersFollowedByUser, followerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getScheduledEventsCreatedByUser = `-- name: getScheduledEventsCreatedByUser :many
SELECT ce.id, ce.user_id, ce.event_title, ce.event_description, ce.from_time, ce.to_time, ce.is_recurring, ce.game_id, ce.created_at, ce.updated_at, ce.deleted_at
FROM CalendarEvents ce
INNER JOIN CalendarEventParticipants cep ON ce.id = cep.event_id
WHERE cep.user_id = $1
  AND ce.from_time >= $2
  AND ce.user_id = $4
  AND ce.deleted_at IS NULL
ORDER BY cep.joined_at ASC
LIMIT $3
`

type getScheduledEventsCreatedByUserParams struct {
	UserID   string
	FromTime int64
	Limit    int32
	UserID_2 string
}

func (q *Queries) getScheduledEventsCreatedByUser(ctx context.Context, arg getScheduledEventsCreatedByUserParams) ([]Calendarevent, error) {
	rows, err := q.db.QueryContext(ctx, getScheduledEventsCreatedByUser,
		arg.UserID,
		arg.FromTime,
		arg.Limit,
		arg.UserID_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Calendarevent
	for rows.Next() {
		var i Calendarevent
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EventTitle,
			&i.EventDescription,
			&i.FromTime,
			&i.ToTime,
			&i.IsRecurring,
			&i.GameID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduledEventsForUser = `-- name: getScheduledEventsForUser :many
SELECT ce.id, ce.user_id, ce.event_title, ce.event_description, ce.from_time, ce.to_time, ce.is_recurring, ce.game_id, ce.created_at, ce.updated_at, ce.deleted_at
FROM CalendarEvents ce
INNER JOIN CalendarEventParticipants cep ON ce.id = cep.event_id
WHERE cep.user_id = $1
  AND ce.from_time >= $2
  AND ce.deleted_at IS NULL
ORDER BY cep.joined_at ASC
LIMIT $3
`

type getScheduledEventsForUserParams struct {
	UserID   string
	FromTime int64
	Limit    int32
}

func (q *Queries) getScheduledEventsForUser(ctx context.Context, arg getScheduledEventsForUserParams) ([]Calendarevent, error) {
	rows, err := q.db.QueryContext(ctx, getScheduledEventsForUser, arg.UserID, arg.FromTime, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Calendarevent
	for rows.Next() {
		var i Calendarevent
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EventTitle,
			&i.EventDescription,
			&i.FromTime,
			&i.ToTime,
			&i.IsRecurring,
			&i.GameID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: getUserByID :one
SELECT id, name, username, email, description, image_url, created_at, updated_at, deleted_at FROM Users WHERE id = $1
`

func (q *Queries) getUserByID(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Username,
		&i.Email,
		&i.Description,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUsersFollowedByUser = `-- name: getUsersFollowedByUser :many
SELECT u.id, u.name, u.image_url, f.created_at
FROM Follows f
INNER JOIN Users u ON f.followed_id = u.id
WHERE f.follower_id = $1 AND f.created_at > $2
ORDER BY f.created_at ASC
LIMIT $3
`

type getUsersFollowedByUserParams struct {
	FollowerID string
	CreatedAt  int64
	Limit      int32
}

type getUsersFollowedByUserRow struct {
	ID        string
	Name      string
	ImageUrl  string
	CreatedAt int64
}

func (q *Queries) getUsersFollowedByUser(ctx context.Context, arg getUsersFollowedByUserParams) ([]getUsersFollowedByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersFollowedByUser, arg.FollowerID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getUsersFollowedByUserRow
	for rows.Next() {
		var i getUsersFollowedByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ImageUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isUserPartOfConversation = `-- name: isUserPartOfConversation :one
SELECT EXISTS (
  SELECT 1
  FROM ConversationParticipants cp
  WHERE cp.conversation_id = $1 AND cp.user_id = $2
)
`

type isUserPartOfConversationParams struct {
	ConversationID string
	UserID         string
}

func (q *Queries) isUserPartOfConversation(ctx context.Context, arg isUserPartOfConversationParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isUserPartOfConversation, arg.ConversationID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isUserRequestOnEventExists = `-- name: isUserRequestOnEventExists :one
SELECT EXISTS (
  SELECT 1
  FROM CalendarEventRequests
  WHERE requesting_user_id = $1
  AND event_id = $2
  AND request_status = 'ACTIVE'
)
`

type isUserRequestOnEventExistsParams struct {
	RequestingUserID string
	EventID          string
}

func (q *Queries) isUserRequestOnEventExists(ctx context.Context, arg isUserRequestOnEventExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isUserRequestOnEventExists, arg.RequestingUserID, arg.EventID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const makeUserUnfollow = `-- name: makeUserUnfollow :exec
DELETE FROM Follows
WHERE follower_id = $1 AND followed_id = $2
`

type makeUserUnfollowParams struct {
	FollowerID string
	FollowedID string
}

func (q *Queries) makeUserUnfollow(ctx context.Context, arg makeUserUnfollowParams) error {
	_, err := q.db.ExecContext(ctx, makeUserUnfollow, arg.FollowerID, arg.FollowedID)
	return err
}

const makeUsersFollow = `-- name: makeUsersFollow :one
INSERT INTO Follows (follower_id, followed_id, created_at)
VALUES ($1, $2, $3)
RETURNING follower_id, followed_id, created_at
`

type makeUsersFollowParams struct {
	FollowerID string
	FollowedID string
	CreatedAt  int64
}

func (q *Queries) makeUsersFollow(ctx context.Context, arg makeUsersFollowParams) (Follow, error) {
	row := q.db.QueryRowContext(ctx, makeUsersFollow, arg.FollowerID, arg.FollowedID, arg.CreatedAt)
	var i Follow
	err := row.Scan(&i.FollowerID, &i.FollowedID, &i.CreatedAt)
	return i, err
}

const makeUsersFriends = `-- name: makeUsersFriends :one
INSERT INTO Friends (user1_id, user2_id, created_at)
VALUES ($1, $2, $3)
RETURNING user1_id, user2_id, created_at
`

type makeUsersFriendsParams struct {
	User1ID   string
	User2ID   string
	CreatedAt int64
}

func (q *Queries) makeUsersFriends(ctx context.Context, arg makeUsersFriendsParams) (Friend, error) {
	row := q.db.QueryRowContext(ctx, makeUsersFriends, arg.User1ID, arg.User2ID, arg.CreatedAt)
	var i Friend
	err := row.Scan(&i.User1ID, &i.User2ID, &i.CreatedAt)
	return i, err
}

const markMessageAsReceivedByUser = `-- name: markMessageAsReceivedByUser :many
DELETE FROM MessageUserMap
USING (
  SELECT id FROM UNNEST($1::VARCHAR[]) AS id
) AS message_ids
WHERE message_id = message_ids.id
  AND receiver_id = $2 RETURNING message_id, receiver_id
`

type markMessageAsReceivedByUserParams struct {
	Column1    []string
	ReceiverID string
}

func (q *Queries) markMessageAsReceivedByUser(ctx context.Context, arg markMessageAsReceivedByUserParams) ([]Messageusermap, error) {
	rows, err := q.db.QueryContext(ctx, markMessageAsReceivedByUser, pq.Array(arg.Column1), arg.ReceiverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Messageusermap
	for rows.Next() {
		var i Messageusermap
		if err := rows.Scan(&i.MessageID, &i.ReceiverID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const organizerRequestToDeleteEvent = `-- name: organizerRequestToDeleteEvent :one
DELETE FROM CalendarEvents
WHERE id = $1
RETURNING id, user_id, event_title, event_description, from_time, to_time, is_recurring, game_id, created_at, updated_at, deleted_at
`

func (q *Queries) organizerRequestToDeleteEvent(ctx context.Context, id string) (Calendarevent, error) {
	row := q.db.QueryRowContext(ctx, organizerRequestToDeleteEvent, id)
	var i Calendarevent
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EventTitle,
		&i.EventDescription,
		&i.FromTime,
		&i.ToTime,
		&i.IsRecurring,
		&i.GameID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const unfriendUsers = `-- name: unfriendUsers :exec
DELETE FROM Friends
WHERE (user1_id = $1 AND user2_id = $2) OR (user1_id = $2 AND user2_id = $1)
`

type unfriendUsersParams struct {
	User1ID string
	User2ID string
}

func (q *Queries) unfriendUsers(ctx context.Context, arg unfriendUsersParams) error {
	_, err := q.db.ExecContext(ctx, unfriendUsers, arg.User1ID, arg.User2ID)
	return err
}

const updateCalendarEventDetails = `-- name: updateCalendarEventDetails :one
UPDATE CalendarEvents
SET 
  event_title = $2, 
  event_description = $3,
  from_time = $4,
  to_time = $5,
  game_id = $7,
  updated_at = $6
WHERE id = $1 RETURNING id, user_id, event_title, event_description, from_time, to_time, is_recurring, game_id, created_at, updated_at, deleted_at
`

type updateCalendarEventDetailsParams struct {
	ID               string
	EventTitle       string
	EventDescription string
	FromTime         int64
	ToTime           int64
	UpdatedAt        sql.NullInt64
	GameID           string
}

func (q *Queries) updateCalendarEventDetails(ctx context.Context, arg updateCalendarEventDetailsParams) (Calendarevent, error) {
	row := q.db.QueryRowContext(ctx, updateCalendarEventDetails,
		arg.ID,
		arg.EventTitle,
		arg.EventDescription,
		arg.FromTime,
		arg.ToTime,
		arg.UpdatedAt,
		arg.GameID,
	)
	var i Calendarevent
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EventTitle,
		&i.EventDescription,
		&i.FromTime,
		&i.ToTime,
		&i.IsRecurring,
		&i.GameID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateCalendarRequest = `-- name: updateCalendarRequest :one
UPDATE CalendarEventRequests
SET request_status = $3, updated_at = $2
WHERE id = $1 AND request_status = 'ACTIVE'
RETURNING id, event_id, requesting_user_id, request_message, request_status, created_at, updated_at
`

type updateCalendarRequestParams struct {
	ID            string
	UpdatedAt     sql.NullInt64
	RequestStatus string
}

func (q *Queries) updateCalendarRequest(ctx context.Context, arg updateCalendarRequestParams) (Calendareventrequest, error) {
	row := q.db.QueryRowContext(ctx, updateCalendarRequest, arg.ID, arg.UpdatedAt, arg.RequestStatus)
	var i Calendareventrequest
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.RequestingUserID,
		&i.RequestMessage,
		&i.RequestStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateDeliveredCountForMessages = `-- name: updateDeliveredCountForMessages :exec
UPDATE Messages
SET delivered_count = delivered_count + 1
WHERE id IN (SELECT UNNEST($1))
`

func (q *Queries) updateDeliveredCountForMessages(ctx context.Context, unnest interface{}) error {
	_, err := q.db.ExecContext(ctx, updateDeliveredCountForMessages, unnest)
	return err
}

const updateLastMessageAtInConversation = `-- name: updateLastMessageAtInConversation :exec
UPDATE Conversations
SET last_message_at = (
  SELECT MAX(created_at)
  FROM Messages
  WHERE conversation_id = $1
)
WHERE id = $1
`

func (q *Queries) updateLastMessageAtInConversation(ctx context.Context, conversationID string) error {
	_, err := q.db.ExecContext(ctx, updateLastMessageAtInConversation, conversationID)
	return err
}

const updateLastMessageSeenAtInConversationParticipant = `-- name: updateLastMessageSeenAtInConversationParticipant :exec
UPDATE ConversationParticipants
SET last_message_seen_at = $3
WHERE conversation_id = $1 AND user_id = $2
`

type updateLastMessageSeenAtInConversationParticipantParams struct {
	ConversationID    string
	UserID            string
	LastMessageSeenAt int64
}

func (q *Queries) updateLastMessageSeenAtInConversationParticipant(ctx context.Context, arg updateLastMessageSeenAtInConversationParticipantParams) error {
	_, err := q.db.ExecContext(ctx, updateLastMessageSeenAtInConversationParticipant, arg.ConversationID, arg.UserID, arg.LastMessageSeenAt)
	return err
}

const updateSeenCountForMessages = `-- name: updateSeenCountForMessages :exec
UPDATE Messages
SET seen_count = seen_count + 1
WHERE id IN (SELECT UNNEST($1))
`

func (q *Queries) updateSeenCountForMessages(ctx context.Context, unnest interface{}) error {
	_, err := q.db.ExecContext(ctx, updateSeenCountForMessages, unnest)
	return err
}

const updateSeenCountForMessagesBetweenTimestamps = `-- name: updateSeenCountForMessagesBetweenTimestamps :exec
UPDATE Messages
SET seen_count = seen_count + 1
WHERE EXISTS (
  SELECT 1
  FROM Messages AS m2
  WHERE m2.id = Messages.id
    AND m2.created_at > $1 AND m2.created_at <= $2
)
`

type updateSeenCountForMessagesBetweenTimestampsParams struct {
	CreatedAt   int64
	CreatedAt_2 int64
}

func (q *Queries) updateSeenCountForMessagesBetweenTimestamps(ctx context.Context, arg updateSeenCountForMessagesBetweenTimestampsParams) error {
	_, err := q.db.ExecContext(ctx, updateSeenCountForMessagesBetweenTimestamps, arg.CreatedAt, arg.CreatedAt_2)
	return err
}

const updateSocialRequest = `-- name: updateSocialRequest :one
UPDATE SocialRequests
SET request_status = $4, updated_at = $5
WHERE target_user_id = $2 AND user_id = $1 AND request_type = $3 AND request_status = 'ACTIVE'
RETURNING id, user_id, target_user_id, request_type, request_message, request_status, created_at, updated_at
`

type updateSocialRequestParams struct {
	UserID        string
	TargetUserID  string
	RequestType   string
	RequestStatus string
	UpdatedAt     sql.NullInt64
}

func (q *Queries) updateSocialRequest(ctx context.Context, arg updateSocialRequestParams) (Socialrequest, error) {
	row := q.db.QueryRowContext(ctx, updateSocialRequest,
		arg.UserID,
		arg.TargetUserID,
		arg.RequestType,
		arg.RequestStatus,
		arg.UpdatedAt,
	)
	var i Socialrequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TargetUserID,
		&i.RequestType,
		&i.RequestMessage,
		&i.RequestStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSocialRequestById = `-- name: updateSocialRequestById :one
UPDATE SocialRequests
SET request_status = $2,
  updated_at = $3
WHERE id = $1
RETURNING id, user_id, target_user_id, request_type, request_message, request_status, created_at, updated_at
`

type updateSocialRequestByIdParams struct {
	ID            string
	RequestStatus string
	UpdatedAt     sql.NullInt64
}

func (q *Queries) updateSocialRequestById(ctx context.Context, arg updateSocialRequestByIdParams) (Socialrequest, error) {
	row := q.db.QueryRowContext(ctx, updateSocialRequestById, arg.ID, arg.RequestStatus, arg.UpdatedAt)
	var i Socialrequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TargetUserID,
		&i.RequestType,
		&i.RequestMessage,
		&i.RequestStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: updateUser :exec
UPDATE Users
SET name = $2, description = $3, image_url = $4
WHERE id = $1
`

type updateUserParams struct {
	ID          string
	Name        string
	Description string
	ImageUrl    string
}

func (q *Queries) updateUser(ctx context.Context, arg updateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.ImageUrl,
	)
	return err
}

const userRequestToJoinEvent = `-- name: userRequestToJoinEvent :one
INSERT INTO CalendarEventRequests (id, event_id, requesting_user_id, request_message, created_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, event_id, requesting_user_id, request_message, request_status, created_at, updated_at
`

type userRequestToJoinEventParams struct {
	ID               string
	EventID          string
	RequestingUserID string
	RequestMessage   string
	CreatedAt        int64
}

func (q *Queries) userRequestToJoinEvent(ctx context.Context, arg userRequestToJoinEventParams) (Calendareventrequest, error) {
	row := q.db.QueryRowContext(ctx, userRequestToJoinEvent,
		arg.ID,
		arg.EventID,
		arg.RequestingUserID,
		arg.RequestMessage,
		arg.CreatedAt,
	)
	var i Calendareventrequest
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.RequestingUserID,
		&i.RequestMessage,
		&i.RequestStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const userRequestToLeaveEvent = `-- name: userRequestToLeaveEvent :one
DELETE FROM CalendarEventParticipants
WHERE event_id = $1 AND user_id = $2
RETURNING event_id, user_id, joined_at, is_organizer
`

type userRequestToLeaveEventParams struct {
	EventID string
	UserID  string
}

func (q *Queries) userRequestToLeaveEvent(ctx context.Context, arg userRequestToLeaveEventParams) (Calendareventparticipant, error) {
	row := q.db.QueryRowContext(ctx, userRequestToLeaveEvent, arg.EventID, arg.UserID)
	var i Calendareventparticipant
	err := row.Scan(
		&i.EventID,
		&i.UserID,
		&i.JoinedAt,
		&i.IsOrganizer,
	)
	return i, err
}
